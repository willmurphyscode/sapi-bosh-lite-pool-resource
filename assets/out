#!/bin/bash
# vim: set ft=sh

set -e

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

source $(dirname $0)/common.sh

source=$1

if [ -z "$source" ]; then
  echo "usage: $0 <path/to/source>"
  exit 1
fi

# for jq
PATH=/usr/local/bin:$PATH

payload=$(mktemp $TMPDIR/git-resource-request.XXXXXX)

cat > $payload <&0

load_pubkey $payload

uri=$(jq -r '.source.uri // ""' < $payload)

if [ -z "$uri" ]; then
  echo "invalid payload (missing uri)"
  exit 1
fi

git clone $uri env-pool

pushd env-pool > /dev/null
  git remote add push-target $uri
popd > /dev/null

operation=$(jq -r '.params.operation // ""' < $payload)
if [ -z "$operation" ]; then
  operation="claim"
fi

commit_message_prefix=$(jq -r '.params.commit_message_prefix // ""' < $payload)

pushd "$source" > /dev/null
  if [ "$operation" == "unclaim" ]; then
    existing_bosh_lite_name=$(cat $(jq -r '.params.name // ""' < $payload))
    export GIT_AUTHOR_NAME='Services API CI'
    export GIT_AUTHOR_EMAIL='servicesapi@localhost'
    export GIT_COMMITTER_NAME='Services API CI'
    export GIT_COMMITTER_EMAIL='servicesapi@localhost'
  else
    export GIT_AUTHOR_NAME=$(cat $(jq -r '.params.author_name // ""' < $payload))
    export GIT_AUTHOR_EMAIL=$(cat $(jq -r '.params.author_email // ""' < $payload))
    export GIT_COMMITTER_NAME=$(cat $(jq -r '.params.committer_name // ""' < $payload))
    export GIT_COMMITTER_EMAIL=$(cat $(jq -r '.params.committer_email // ""' < $payload))

    story=$(cat $(jq -r '.params.story // ""' < $payload))
  fi
popd > /dev/null

function msg {
  echo -e $1
}

function realpath {
  echo $(cd $(dirname "$1") && pwd -P)/$(basename "$1")
}

function claim_random_environment() {
  pool="bosh-lites"

  git checkout master
  git pull --rebase --quiet

  for f in ./${pool}/unclaimed/*; do
    test -f "$f" || continue

    msg "Claiming $( basename $f )..."
    claim_specific_environment $(basename $f)
    return $?
  done

  msg "No unclaimed environment found in $pool"
  return 1
}

function claim_specific_environment() {
  env=$1

  file=`find . -name $env`

  if [ "$file" == "" ]; then
    echo $env does not exist
    return 1
  fi

  set +e
  file_unclaimed=`echo $file | grep claim | grep -v unclaim`
  set -e

  if [ $file_unclaimed ]; then
    msg $env could not be claimed
    return 1
  fi

  newfile=`echo ${file} | sed -e 's/unclaimed/claimed/'`

  git mv $file $newfile

  git add "${newfile}"
}

function create_env_dir() {
                    msg "Writing out .envrc..."
  env_file="$1"
  env_name="$(basename "${env_file}")"

  mkdir -p "${env_name}"

                    green='\033[32m'
                    nc='\033[0m'

                    source "${env_file}"
  cat << EOF > "${env_name}/.envrc"
# NOTE: this file was auto-generated by 'claim_bosh_lite' alias

target_bosh "${env_name}"

echo -e "\n##################################\n"
echo -e "${green}Some example commands for BOSH + CF${nc}"

default_cmd='bosh deploy ~/workspace/cf-deployment/cf-deployment.yml -v system_domain=\$BOSH_LITE_DOMAIN -o ~/workspace/capi-ci/cf-deployment-operations/use-latest-stemcell.yml -o ~/workspace/capi-ci/cf-deployment-operations/skip-cert-verify.yml -o ~/workspace/cf-deployment/operations/bosh-lite.yml -o ~/workspace/cf-deployment/operations/use-compiled-releases.yml'

echo -e "${green}\n## Target this bosh-lite environment ##${nc}"
echo "target_bosh ${env_name}"

# echo -e "${green}\n## Create and upload CAPI release ##${nc}"
# echo "upload_capi_release"

# echo -e "${green}\n## Deploy CF with latest CAPI release ##${nc}"
# echo "create_and_deploy"

# echo -e "${green}\n## Deploy CF noninteractively with latest CAPI release ##${nc}"
# echo "create_and_force_deploy"

# echo -e "${green}\n## Connect to this environment mysql ##${nc}"
# echo "mysql_bosh_lite"

# echo -e "${green}\n## Deploy CF with defaults ##${nc}"
# echo "\${default_cmd}"

echo -e "${green}\n## Target CF API ##${nc}"
echo "cf api https://api.${BOSH_LITE_DOMAIN} --skip-ssl-validation"

# echo -e "${green}\n## Target CF API, login as admin ##${nc}"
# echo "target_cf"

# echo -e "${green}\n## Target CF API, login as admin, and create org and space##${nc}"
# echo "bootstrap_cf"

# echo -e "${green}\n## Target UAA API, login as uaa admin ##${nc}"
# echo "target_uaa"

echo -e "${green}\n## Retrieve CF admin password ##${nc}"
echo 'credhub login --skip-tls-validation'
echo "credhub get --name '/bosh-lite/cf/cf_admin_password' --output-json | jq -r '.value'"
#TODO: Get this variant working:
#echo 'CF_PASSWORD=\$(credhub get --name "/bosh-lite/cf/cf_admin_password" --output-json | jq -r ".value" | tee /dev/tty)'

echo -e "${green}\n## Unclaim this environment ##${nc}"
echo "unclaim_bosh_lite ${env_name}"

echo -e "${green}\n## Short circuit CC traffic into local process ##${nc}"
echo "~/workspace/capi-release/src/cloud_controller_ng/scripts/short-circuit-cc"

echo -e "${green}\n## Print this help text ##${nc}"
echo ". .envrc"

echo -e "\n##################################\n"
EOF
  git add "${env_name}"
}

function unclaim_bosh_lite() {
  working_pool="bosh-lites"
  broken_pool="broken-bosh-lites"

  if [ $# -eq 0 ]; then
    echo "Usage: $0 env_name"
    return 1
  fi

  env=$1

  file="$(find "${working_pool}" -name "${env}")"

  if [ "$file" == "" ]; then
    echo "$env does not exist in ${working_pool}"
    return 1
  fi

  git mv "${file}" "${broken_pool}/unclaimed/"
  if [ -d "${env}" ]; then
    git rm -rf "${env}" && \rm -rf "${env}"
  fi

  # trigger destroy-bosh-lite job
  date +%s >| .trigger-bosh-lites-destroy && git add .trigger-bosh-lites-destroy

  git commit --quiet -m"releasing $env" --no-verify
  git push --quiet

  echo "Done"
}

function commit_and_push() {
  git commit --quiet --message "${commit_message_prefix}CI-claim ${env} for ${story}"
  msg "Pushing reservation to $( basename $PWD )..."
  git push push-target
}

>&2 cd env-pool

if [ "$operation" == "claim" ]; then
  >&2 claim_random_environment $requested_input
  env_file="$(realpath $newfile)"

  >&2 create_env_dir "${env_file}"
  >&2 commit_and_push

  jq -n "{
    version: {name: \"${env}\"},
    metadata: []
  }" >&3
elif [ "$operation" == "unclaim" ]; then
  >&2 unclaim_bosh_lite "$existing_bosh_lite_name"

  jq -n "{
    version: {name: \"${existing_bosh_lite_name}\"},
    metadata: []
  }" >&3
else
  echo "invalid payload (expected operation to be 'claim' or 'unclaim')"
  exit 1
fi
